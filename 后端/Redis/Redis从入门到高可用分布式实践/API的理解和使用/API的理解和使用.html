<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>API的理解和使用 | 吃饭睡觉打豆豆</title>
    <meta name="description" content=" ">
    <link rel="icon" href="/favicon.png">
  <link rel="manifest" href="/images/pic.jpg">
  <link rel="apple-touch-icon" href="/images/pic.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    
    <link rel="preload" href="/assets/css/0.styles.0f5aefa9.css" as="style"><link rel="preload" href="/assets/js/app.2ed4a716.js" as="script"><link rel="preload" href="/assets/js/2.0d3085da.js" as="script"><link rel="preload" href="/assets/js/4.6eb19324.js" as="script"><link rel="prefetch" href="/assets/js/10.56332b24.js"><link rel="prefetch" href="/assets/js/11.dc70378b.js"><link rel="prefetch" href="/assets/js/12.c27a5cc7.js"><link rel="prefetch" href="/assets/js/13.cd445f8c.js"><link rel="prefetch" href="/assets/js/14.a519b732.js"><link rel="prefetch" href="/assets/js/15.71d77324.js"><link rel="prefetch" href="/assets/js/16.2282c2e6.js"><link rel="prefetch" href="/assets/js/17.84ef61f7.js"><link rel="prefetch" href="/assets/js/18.f341b90a.js"><link rel="prefetch" href="/assets/js/19.28081019.js"><link rel="prefetch" href="/assets/js/20.400cb076.js"><link rel="prefetch" href="/assets/js/21.54d5f8e0.js"><link rel="prefetch" href="/assets/js/22.302d416f.js"><link rel="prefetch" href="/assets/js/23.bcb3ed03.js"><link rel="prefetch" href="/assets/js/24.7b575690.js"><link rel="prefetch" href="/assets/js/25.eef0e9ab.js"><link rel="prefetch" href="/assets/js/26.e5319516.js"><link rel="prefetch" href="/assets/js/27.7a39b9af.js"><link rel="prefetch" href="/assets/js/28.53ab4bfa.js"><link rel="prefetch" href="/assets/js/29.6da66f35.js"><link rel="prefetch" href="/assets/js/3.579889d3.js"><link rel="prefetch" href="/assets/js/30.7ce82f78.js"><link rel="prefetch" href="/assets/js/31.4f595fb1.js"><link rel="prefetch" href="/assets/js/32.4ea77839.js"><link rel="prefetch" href="/assets/js/33.7fa19738.js"><link rel="prefetch" href="/assets/js/34.ca110b46.js"><link rel="prefetch" href="/assets/js/35.af16c3a0.js"><link rel="prefetch" href="/assets/js/36.146105e1.js"><link rel="prefetch" href="/assets/js/37.a725ceea.js"><link rel="prefetch" href="/assets/js/38.cadf49e9.js"><link rel="prefetch" href="/assets/js/39.537fbddf.js"><link rel="prefetch" href="/assets/js/40.e9f8e128.js"><link rel="prefetch" href="/assets/js/41.19f8fb66.js"><link rel="prefetch" href="/assets/js/42.0a39bbea.js"><link rel="prefetch" href="/assets/js/43.0ed9d746.js"><link rel="prefetch" href="/assets/js/44.89f92846.js"><link rel="prefetch" href="/assets/js/45.2e313083.js"><link rel="prefetch" href="/assets/js/46.a4cc6906.js"><link rel="prefetch" href="/assets/js/47.7061b060.js"><link rel="prefetch" href="/assets/js/48.d40e2261.js"><link rel="prefetch" href="/assets/js/49.07b001ce.js"><link rel="prefetch" href="/assets/js/5.b5ba2def.js"><link rel="prefetch" href="/assets/js/50.5b6f7890.js"><link rel="prefetch" href="/assets/js/51.23496ee3.js"><link rel="prefetch" href="/assets/js/52.687b8402.js"><link rel="prefetch" href="/assets/js/53.c79069f6.js"><link rel="prefetch" href="/assets/js/54.69c422ad.js"><link rel="prefetch" href="/assets/js/55.0b2eddb9.js"><link rel="prefetch" href="/assets/js/56.a908f57d.js"><link rel="prefetch" href="/assets/js/57.c1b2dbbd.js"><link rel="prefetch" href="/assets/js/58.07a79fec.js"><link rel="prefetch" href="/assets/js/59.0e076c5f.js"><link rel="prefetch" href="/assets/js/6.6725e2bb.js"><link rel="prefetch" href="/assets/js/60.45e33df3.js"><link rel="prefetch" href="/assets/js/61.8aca7760.js"><link rel="prefetch" href="/assets/js/62.302ed63d.js"><link rel="prefetch" href="/assets/js/63.097511c4.js"><link rel="prefetch" href="/assets/js/64.a9c1111f.js"><link rel="prefetch" href="/assets/js/65.5c7e6580.js"><link rel="prefetch" href="/assets/js/66.4d31114d.js"><link rel="prefetch" href="/assets/js/67.a9492502.js"><link rel="prefetch" href="/assets/js/68.0faaaa93.js"><link rel="prefetch" href="/assets/js/69.bfbae9d0.js"><link rel="prefetch" href="/assets/js/7.5d32872a.js"><link rel="prefetch" href="/assets/js/8.63ab5f4b.js"><link rel="prefetch" href="/assets/js/9.a0ac733d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0f5aefa9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">吃饭睡觉打豆豆</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">BackEnd</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/后端/Java/JavaSE/变量.html" class="nav-link">JavaSE</a></li><li class="dropdown-subitem"><a href="/后端/Java/JavaEE/" class="nav-link">JavaEE</a></li></ul></li><li class="dropdown-item"><!----> <a href="/后端/Redis/Redis从入门到高可用分布式实践/目录说明.html" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/后端/Kafka/Kafka原理介绍.html" class="nav-link">Kafka</a></li><li class="dropdown-item"><!----> <a href="/后端/Python/" class="nav-link">Python</a></li><li class="dropdown-item"><h4>Spring</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/后端/Spring源码解析/Spring源码解析.html" class="nav-link">Spring源码解析</a></li></ul></li><li class="dropdown-item"><h4>Linux</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/linux/" class="nav-link">Linux</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">FrontEnd</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/frontend/" class="nav-link">Frontend</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/数据结构与算法/数据结构不难/" class="nav-link">数据结构不难</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/算法很美/" class="nav-link">算法很美</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">大数据</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/大数据/Hadoop/README.html" class="nav-link">Hadoop</a></li></ul></div></div> <a href="https://github.com/DYX884877791/DYX884877791.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">BackEnd</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/后端/Java/JavaSE/变量.html" class="nav-link">JavaSE</a></li><li class="dropdown-subitem"><a href="/后端/Java/JavaEE/" class="nav-link">JavaEE</a></li></ul></li><li class="dropdown-item"><!----> <a href="/后端/Redis/Redis从入门到高可用分布式实践/目录说明.html" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/后端/Kafka/Kafka原理介绍.html" class="nav-link">Kafka</a></li><li class="dropdown-item"><!----> <a href="/后端/Python/" class="nav-link">Python</a></li><li class="dropdown-item"><h4>Spring</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/后端/Spring源码解析/Spring源码解析.html" class="nav-link">Spring源码解析</a></li></ul></li><li class="dropdown-item"><h4>Linux</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/linux/" class="nav-link">Linux</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">FrontEnd</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/frontend/" class="nav-link">Frontend</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/数据结构与算法/数据结构不难/" class="nav-link">数据结构不难</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/算法很美/" class="nav-link">算法很美</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">大数据</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/大数据/Hadoop/README.html" class="nav-link">Hadoop</a></li></ul></div></div> <a href="https://github.com/DYX884877791/DYX884877791.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/" class="sidebar-link">首页</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Redis从入门到高可用分布式实践</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/后端/Redis/Redis从入门到高可用分布式实践/目录说明.html" class="sidebar-link">目录说明</a></li><li><a href="/后端/Redis/Redis从入门到高可用分布式实践/Redis初识/Redis初识.html" class="sidebar-link">Redis初识</a></li><li><a href="/后端/Redis/Redis从入门到高可用分布式实践/API的理解和使用/API的理解和使用.html" class="active sidebar-link">API的理解和使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/后端/Redis/Redis从入门到高可用分布式实践/API的理解和使用/API的理解和使用.html#通用命令" class="sidebar-link">通用命令</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/后端/Redis/Redis从入门到高可用分布式实践/API的理解和使用/API的理解和使用.html#全局命令" class="sidebar-link">全局命令</a></li><li class="sidebar-sub-header"><a href="/后端/Redis/Redis从入门到高可用分布式实践/API的理解和使用/API的理解和使用.html#数据结构与内部编码" class="sidebar-link">数据结构与内部编码</a></li><li class="sidebar-sub-header"><a href="/后端/Redis/Redis从入门到高可用分布式实践/API的理解和使用/API的理解和使用.html#单线程架构" class="sidebar-link">单线程架构</a></li></ul></li><li class="sidebar-sub-header"><a href="/后端/Redis/Redis从入门到高可用分布式实践/API的理解和使用/API的理解和使用.html#五种主要的数据结构" class="sidebar-link">五种主要的数据结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/后端/Redis/Redis从入门到高可用分布式实践/API的理解和使用/API的理解和使用.html#字符串" class="sidebar-link">字符串</a></li><li class="sidebar-sub-header"><a href="/后端/Redis/Redis从入门到高可用分布式实践/API的理解和使用/API的理解和使用.html#哈希" class="sidebar-link">哈希</a></li><li class="sidebar-sub-header"><a href="/后端/Redis/Redis从入门到高可用分布式实践/API的理解和使用/API的理解和使用.html#列表" class="sidebar-link">列表</a></li><li class="sidebar-sub-header"><a href="/后端/Redis/Redis从入门到高可用分布式实践/API的理解和使用/API的理解和使用.html#集合" class="sidebar-link">集合</a></li><li class="sidebar-sub-header"><a href="/后端/Redis/Redis从入门到高可用分布式实践/API的理解和使用/API的理解和使用.html#有序集合" class="sidebar-link">有序集合</a></li></ul></li></ul></li><li><a href="/后端/Redis/Redis从入门到高可用分布式实践/Redis客户端/Redis客户端.html" class="sidebar-link">Redis客户端</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="api的理解和使用"><a href="#api的理解和使用" aria-hidden="true" class="header-anchor">#</a> API的理解和使用</h1> <h2 id="通用命令"><a href="#通用命令" aria-hidden="true" class="header-anchor">#</a> 通用命令</h2> <h3 id="全局命令"><a href="#全局命令" aria-hidden="true" class="header-anchor">#</a> 全局命令</h3> <ol><li>keys：</li></ol> <ul><li>遍历出redis中所有的key(keys *)<div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6380<span class="token operator">&gt;</span> <span class="token keyword">set</span> hello world
OK
127.0.0.1:6380<span class="token operator">&gt;</span> <span class="token keyword">set</span> java good
OK
127.0.0.1:6380<span class="token operator">&gt;</span> <span class="token keyword">set</span> python good
OK
127.0.0.1:6380<span class="token operator">&gt;</span> <span class="token keyword">set</span> php best
OK
127.0.0.1:6380<span class="token operator">&gt;</span> keys *
1<span class="token punctuation">)</span> <span class="token string">&quot;php&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;python&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;java&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;hello&quot;</span>
</code></pre></div></li> <li>keys [pattern]：遍历所有key(匹配正则)<div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6380<span class="token operator">&gt;</span> keys he*
1<span class="token punctuation">)</span> <span class="token string">&quot;hello&quot;</span>
127.0.0.1:6380<span class="token operator">&gt;</span> keys p
<span class="token punctuation">(</span>empty list or set<span class="token punctuation">)</span>
127.0.0.1:6380<span class="token operator">&gt;</span> keys *p
1<span class="token punctuation">)</span> <span class="token string">&quot;php&quot;</span>
127.0.0.1:6380<span class="token operator">&gt;</span> keys ^p
<span class="token punctuation">(</span>empty list or set<span class="token punctuation">)</span>
127.0.0.1:6380<span class="token operator">&gt;</span> keys ^p* 
</code></pre></div><ul><li>keys命令一般不在生产环境中使用，生产环境中key太多，容易造成阻塞，生产环境中可以使用scan 命令</li></ul></li></ul> <ol start="2"><li>dbsize：计算key的总数</li></ol> <ul><li>dbsize命令在计算总数时不会遍历所有键，而是直接获取Redis内置的键总数变量，所以dbsize命令的时间复杂度是o(1)</li> <li>keys命令会遍历所有的键，所以它的时间复杂度是o(n)，当Redis中保存了大量的键时，禁止在生产环境上使用keys命令<div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6380<span class="token operator">&gt;</span> dbsize
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
</code></pre></div></li></ul> <ol start="3"><li><p>exists key：判断key是否存在，如果存在返回1，否则返回0，时间复杂度为o(1)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6380<span class="token operator">&gt;</span> exists hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6380<span class="token operator">&gt;</span> exists hello1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
</code></pre></div></li> <li><p>del key [key...]：删除指定的key，可以同时删除多个key，返回结果为删除成功的个数，如果键不存在，则返回0</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6380<span class="token operator">&gt;</span> del hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6380<span class="token operator">&gt;</span> del java python
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
127.0.0.1:6380<span class="token operator">&gt;</span> del hello1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1:6380<span class="token operator">&gt;</span> del php hello1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre></div></li> <li><p>expire key seconds：设置key在多少秒以后过期，当超过过期时间后，键会自动删除，此命令可以设置过期的毫秒数</p></li> <li><p>ttl key：查看key剩余的过期时间，有三种返回值</p> <ul><li>大于或等于0的整数：key的过期时间，等于0表示此瞬间后会被删除</li> <li>-1：键没有设置过期时间，会一直存在</li> <li>-2：键不存在</li></ul></li> <li><p>persist key：去掉键的过期时间，使键会一直存在</p></li> <li><p>type key：返回key的类型</p> <ul><li>type主要有以下类型：string、hash、list、set、zset、none(如果键不存在返回none)<div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6380<span class="token operator">&gt;</span> <span class="token keyword">set</span> hello world
OK
127.0.0.1:6380<span class="token operator">&gt;</span> <span class="token function">type</span> hell
none
127.0.0.1:6380<span class="token operator">&gt;</span> <span class="token function">type</span> hello
string
127.0.0.1:6380<span class="token operator">&gt;</span> sadd myset 1 2 3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1:6380<span class="token operator">&gt;</span> <span class="token function">type</span> myset
<span class="token keyword">set</span>
</code></pre></div></li></ul></li> <li><p>各命令的时间复杂度：</p> <table><thead><tr><th>命令</th> <th>时间复杂度</th></tr></thead> <tbody><tr><td>keys</td> <td>o(n)</td></tr> <tr><td>dbsize</td> <td>o(1)</td></tr> <tr><td>del</td> <td>o(1)</td></tr> <tr><td>exists</td> <td>o(1)</td></tr> <tr><td>expire</td> <td>o(1)</td></tr> <tr><td>type</td> <td>o(1)</td></tr></tbody></table></li></ol> <h3 id="数据结构与内部编码"><a href="#数据结构与内部编码" aria-hidden="true" class="header-anchor">#</a> 数据结构与内部编码</h3> <ol><li>type命令实际上返回的是当前键的数据结构类型：string、hash、list、set、zset；但这些只是Redis对外的数据结构，但Redis内部每种数据结构都有自己的内部编码实现，而且是多种实现，会在合适的场景下选择合适的内部编码</li> <li>各类型的多种内部编码实现：<img src="/assets/img/7.0290dedd.png" alt="内部编码实现"></li> <li>redis对象
<ul><li><p>redis的键值都是redisObject对象，即在创建时会生成一个用于键名的redisObject对象和一个用于键值的redisObject对象</p></li> <li><p>那么redis是如何关联键值对？这都是依赖于键空间，其结构是字典(key-value)用于绑定redisObject键值对</p></li> <li><p>redisObject，其结构体如下：</p> <div class="language-C extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
<span class="token comment">// 类型</span>
<span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
<span class="token comment">// 编码</span>
<span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
<span class="token comment">// 指向数据的指针</span>
<span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>

<span class="token comment">// 记录对象最后一次被程序访问时间，用于计算空转时长(当前时间-lru)</span>
<span class="token keyword">unsigned</span> lru<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">;</span> <span class="token comment">/* lru time (relative to server.lruclock) */</span>
<span class="token comment">// 引用计数，用于内存回收</span>
<span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>其中字段描述：</p> <table><thead><tr><th>字段</th> <th>描述</th> <th>值</th></tr></thead> <tbody><tr><td>type</td> <td>记录了对象的类型名称</td> <td>string，list，hash，set，zset</td></tr> <tr><td>encoding</td> <td>记录了对象所使用的编码名称</td> <td>int，embstr，raw，hashtable， ziplist，intset，linkedlist，skiplist</td></tr> <tr><td>lru</td> <td>记录对象最后一次被程序访问的时间</td> <td></td></tr> <tr><td>refcount</td> <td>引用计数</td> <td>初始值为1</td></tr></tbody></table></li> <li><p>redisObject<img src="/assets/img/8.dcee75f1.png" alt="redisObject结构图"></p></li></ul></li> <li>类型与编码格式
<ul><li>REDIS_OBJECT中的ptr指向各类型的值，并且针对不同类型会有不同的编码格式，甚至同一类型根据值的不同也有不同的编码格式；</li> <li>redis会根据值的长度以及个数的不同选择其对应的编码格式，都是为了更好的优化对象在不同场景下的使用效率</li> <li>以下便是所有的对象所对应的编码格式以及场景：<img src="/assets/img/9.47398f56.png" alt="编码格式"></li></ul></li></ol> <h3 id="单线程架构"><a href="#单线程架构" aria-hidden="true" class="header-anchor">#</a> 单线程架构</h3> <ol><li>Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务</li> <li>Redis中的一条命令从客户端达到服务端不会立刻会执行，所有命令都会进入一个队列中，然后逐个被执行，但保证不会存在两条命令同时被执行，所以不会产生并发问题</li> <li>为什么单线程还能这么快?
<ul><li>纯内存访问</li> <li>非阻塞IO，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间</li> <li>由于是单线程，避免了线程之间的切换和竞态产生的消耗</li></ul></li> <li>注意：如果Redis中某个命令执行时间过长，会造成其他命令的阻塞，对于Redis这种高性能的服务来说很致命。所以在Redis中拒绝长命令，比如keys、flushall、flushdb、slow lua script、mutil/exec、operate big value等</li></ol> <h2 id="五种主要的数据结构"><a href="#五种主要的数据结构" aria-hidden="true" class="header-anchor">#</a> 五种主要的数据结构</h2> <h3 id="字符串"><a href="#字符串" aria-hidden="true" class="header-anchor">#</a> 字符串</h3> <ul><li><p>命令：</p> <ol><li><p>设置值：set key value [ex seconds] [px milliseconds] [nx|xx]</p> <ol><li>value可以为字符串、数字(包括整数与非整数)、二进制数、JSON串(字符串的限制不能超过512MB)，设置成功则返回O</li> <li>ex seconds：设置多少秒后过期</li> <li>px milliseconds：设置多少毫秒后过期</li> <li>nx：当键不存在时才能设置成功，否则不成功，常用于键的添加</li> <li>xx：与nx相反，当键必须存在时才能设置成功，常用于键的更新</li> <li>除了set命令，Redis还提供了setnx、setex命令，分别于nx、xx作用相同</li></ol></li> <li><p>获取值：get key，获取对应的value，当key不存在时，返回空(nil)，时间复杂度为o(1)</p></li> <li><p>删除键：del key，当删除成功返回1，删除不存在的键时，返回0</p></li></ol></li> <li><p>实例：</p> <ol><li>设置key-value后查询并删除<div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> hello world
OK
127.0.0.1:6381<span class="token operator">&gt;</span> get hello
<span class="token string">&quot;world&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> del hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6381<span class="token operator">&gt;</span> get hello
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
127.0.0.1:6381<span class="token operator">&gt;</span> del hello1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
</code></pre></div></li> <li>设置ex过期时间(多少秒后过期)<div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> hello world ex 10
OK
127.0.0.1:6381<span class="token operator">&gt;</span> ttl hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 8
127.0.0.1:6381<span class="token operator">&gt;</span> get hello
<span class="token string">&quot;world&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> ttl hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -2
127.0.0.1:6381<span class="token operator">&gt;</span> get hello
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre></div></li> <li>设置px过期时间(多少毫秒后过期)<div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> hello world px 10000
OK
127.0.0.1:6381<span class="token operator">&gt;</span> ttl hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 8
</code></pre></div></li> <li>当ex参数与px参数同时存在时，后面的过期时间会覆盖前面的过期时间<div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> hello world ex 20 px 10000
OK
127.0.0.1:6381<span class="token operator">&gt;</span> ttl hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 7
127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> hello world px 10000 ex 20
OK
127.0.0.1:6381<span class="token operator">&gt;</span> ttl hello
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 19
</code></pre></div></li> <li>nx与xx，
<ul><li>nx：if not exist，当key不存在时才能设置成功</li></ul> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> exist_key_test value
OK
127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> exist_key_test value1 nx
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre></div><ul><li>xx：if exist，当key存在时才能设置成功</li></ul> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> not_exist_key_test value xx
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre></div></li> <li>setnx与setex
<ul><li>setnx：当key不存在时才能设置成功，setnx key value，设置成功返回1，否则返回0，利用此命令可以实现Redis的分布式锁，<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener noreferrer">Redis官方对分布式锁的实现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> setnx exist_key_test value1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1:6381<span class="token operator">&gt;</span> setnx not_exist_key_test value1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre></div><ul><li>setex：当key存在时才能设置成功，SETEX key seconds value，将键key的值设置（覆盖）为值value，并设置其过期时间，以秒为单位，当 seconds 参数不合法时，返回一个错误。
且SETEX 是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成。</li></ul> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> setex exist_key_test value1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6381<span class="token operator">&gt;</span> setex exist_key_test -1 value2
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR invalid expire <span class="token function">time</span> <span class="token keyword">in</span> setex
</code></pre></div><ul><li>setnx/setex与set的不同：set命令不管存不存在，都会设置值</li></ul></li> <li>批量设置（获取）值：mset、mget
<ul><li>批量设置：mset key1 value1 [key2 value2] [key3 value3]...</li> <li>批量获取：mget key1 [key2] [key3]...</li></ul> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> mset a1 value1 a2 value2 a3 value3 a4 value4
OK
127.0.0.1:6381<span class="token operator">&gt;</span> mget a1 a3 a4
1<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value3&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> mget a1 a4 a5
1<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
3<span class="token punctuation">)</span> <span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre></div></li> <li>计数：incr、decr、incrby、decrby
<ul><li><p>incr：key的value值自增1，返回的结果分为三种情况</p> <ul><li>value不是整数，返回错误</li> <li>value是整数，返回增加1后的结果</li> <li>key不存在，按照值为0增加1，返回结果为1</li></ul></li> <li><p>decr：key的value值自减1，如果key不存在，返回结果为-1</p></li> <li><p>incrby：incrby key k，增加k</p></li> <li><p>decrby：decrby key k，减少k</p></li> <li><p>incrbyfloat：自增浮点数：decrbyfloat key k</p></li> <li><p>...</p></li> <li><p>很多存储系统和编程语言内部使用CAS机制实现计数功能，会有一定的cpu开销，但在Redis中完全不存在这个问题，因为Redis是单线程架构，任何命令到了Redis服务端都要顺序执行</p></li></ul></li> <li>append：追加值：append key value向字符串尾部追加值</li> <li>strlen：字符串长度：strlen key，返回字符串的长度，如果是中文字符，每个中文字符占用3个字节</li> <li>getset：给key设置一个新的value值，但返回的是原来的value值</li></ol> <pre><code>```shell
127.0.0.1:6381&gt; getset hello value1
(nil)
127.0.0.1:6381&gt; getset hello value2
&quot;value1&quot;
127.0.0.1:6381&gt; getset hello value3
&quot;value2&quot;
```
</code></pre> <ol start="12"><li>getrange/setrange：</li></ol> <pre><code>* getrange key start end：获取字符串指定下标所有的值，包括开始下标和结束下标
* setrange key index value：设置指定下标所对应的值
</code></pre></li> <li><p>String的内部编码(三种内部编码实现)</p> <ul><li>int：8个字节的长整形，当value为非整数时，视为字符串</li> <li>embstr：小于等于30字节的字符串</li> <li>raw：大于39个字节的字符串</li></ul> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> key1 12345678
OK
127.0.0.1:6381<span class="token operator">&gt;</span> object encoding key1
<span class="token string">&quot;int&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> key1 2.3
OK
127.0.0.1:6381<span class="token operator">&gt;</span> object encoding key1
<span class="token string">&quot;embstr&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> key2 2
OK
127.0.0.1:6381<span class="token operator">&gt;</span> object encoding key2
<span class="token string">&quot;int&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> key3 2.000000000000000000000000000000000000000000000000000000000000000000000000000000
OK
127.0.0.1:6381<span class="token operator">&gt;</span> object encoding key3
<span class="token string">&quot;raw&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> <span class="token keyword">set</span> key4 <span class="token string">&quot;test&quot;</span>
OK
127.0.0.1:6381<span class="token operator">&gt;</span> object encoding key4
<span class="token string">&quot;embstr&quot;</span>
</code></pre></div></li> <li><p>应用：分布式锁(setnx)、Redis的分布式ID生成器(incr)</p></li></ul> <h3 id="哈希"><a href="#哈希" aria-hidden="true" class="header-anchor">#</a> 哈希</h3> <p>哈希键值结构：在Redis中，哈希类型是指某个键的值本身又是一个键值对的结构，形如value={field1,value1},{field2,value2}...{fieldN,valueN}，Redis键值对和哈希类型二者的关系可以用下图表示，与String类型进行对比：<img src="/assets/img/10.130730a4.png" alt="哈希与字符串类型对比">
哈希类型中的映射关系叫做field-value，注意这里的value指的是field对应的值，而不是键对应的值</p> <ul><li><p>特点
field-value与大多数编程中的字典结构类似，比如Java中的Map，Python中的字典，其中field不能相同，而value可以相同</p></li> <li><p>重要API</p> <ol><li><p>设置值：</p> <ul><li><p>hset key field获取hash key所对应的field的value，时间复杂度为O(1)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> hset hashkey hashfield hashvalue
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre></div></li> <li><p>上述示例中key为hashkey，而field是hashfield，设置成功返回1，否则返回0，此外Redis还提供了hsetnx命令，作用与setnx类似，只不过作用域由键变为了field，如果哈希的key已存在而field不存在，hsetnx能设置成功，如果field已存在，则不能设置成功，说明作用域是在field上</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> hsetnx hashkey hashfield1 hashvalue1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6381<span class="token operator">&gt;</span> hsetnx hashkey hashfield hashvalue1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
</code></pre></div></li></ul></li> <li><p>获取值：hget key field设置hash key所对应的field的value</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> hget hashkey hashfield
<span class="token string">&quot;hashvalue&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> hget hashkey hashfield1
<span class="token string">&quot;hashvalue1&quot;</span>
</code></pre></div></li> <li><p>删除值：hdel key field删除hash key所对应的field的value，如果只删除hash key则报错</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> hdel hashkey hashfield
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6381<span class="token operator">&gt;</span> hget hashkey hashfield
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
  127.0.0.1:6381<span class="token operator">&gt;</span> hdel hashkey
  <span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR wrong number of arguments <span class="token keyword">for</span> <span class="token string">'hdel'</span> <span class="token function">command</span>
</code></pre></div></li> <li><p>hgetall：hgetall key：获取hash key的所有field及对应的value，时间复杂度为o(n)，注意：小心使用此命令，如果hash元素个数过多，可能会阻塞Redis，如果要部分获取field，使用hmget命令，如果要全部获取field-value的话，可以使用hscan命令，该命令会渐进式遍历哈希类型</p></li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code>  127.0.0.1:6381<span class="token operator">&gt;</span> hset hashkey hashfield hashvalue
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
  127.0.0.1:6381<span class="token operator">&gt;</span> hgetall hashkey
  1<span class="token punctuation">)</span> <span class="token string">&quot;hashfield&quot;</span>
  2<span class="token punctuation">)</span> <span class="token string">&quot;hashvalue&quot;</span>
  3<span class="token punctuation">)</span> <span class="token string">&quot;hashfield1&quot;</span>
	4<span class="token punctuation">)</span> <span class="token string">&quot;hashvalue1&quot;</span>
</code></pre></div><ol start="5"><li><p>hexists：hexists key field：判断hash key是否有field，复杂度为o(1)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> hexists hashkey hashfield
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
  127.0.0.1:6381<span class="token operator">&gt;</span> hexists hashkey hashfield1
  <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
  127.0.0.1:6381<span class="token operator">&gt;</span> hexists hashkey hashfield2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0 
</code></pre></div></li> <li><p>hlen：hlen key：获取hash key的field数量，复杂度为o(1)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> hlen hashkey
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
</code></pre></div></li> <li><p>hmset：hmset key field1 value1 field2 value2 ... fieldN valueN批量设置hash key的一批field的value值，时间复杂度为o(n)</p></li> <li><p>hmget：hmget key field1 field2... fieldN批量获取hash key的一批field对应的值，时间复杂度为o(n)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> hmset hashkey1 hashfield hashvalue hashfield1 hashvalue1 hashfield2 hashvalue2
OK
127.0.0.1:6381<span class="token operator">&gt;</span> hmget hashkey1 hashfield hashfield1 hashfield2
1<span class="token punctuation">)</span> <span class="token string">&quot;hashvalue&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;hashvalue1&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;hashvalue2&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> hlen hashkey1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
</code></pre></div></li> <li><p>hvals key：返回hash key对应的所有field的value，时间复杂度为o(n)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> hvals hashkey1
1<span class="token punctuation">)</span> <span class="token string">&quot;hashvalue&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;hashvalue1&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;hashvalue2&quot;</span>
</code></pre></div></li> <li><p>hkeys key：返回hash key对应的所有field，时间复杂度为o(n)</p></li> <li><div class="language-shell extra-class"><pre class="language-shell"><code> 127.0.0.1:6381<span class="token operator">&gt;</span> hkeys hashkey1
 1<span class="token punctuation">)</span> <span class="token string">&quot;hashfield&quot;</span>
 2<span class="token punctuation">)</span> <span class="token string">&quot;hashfield1&quot;</span>
 3<span class="token punctuation">)</span> <span class="token string">&quot;hashfield2&quot;</span>
</code></pre></div></li> <li><p>hincrby、hincrbyfloat，效果如图incrby与incrbyfloat，但作用域是field</p></li> <li><p>hstrlen key field：计算hash key中field对应的value的长度，只在Redis3.2以上版本中有效</p></li></ol></li> <li><p>Hash实战</p> <ul><li>记录用户信息</li> <li>用户的id作为hash中的key，而该用户包含的各属性作为同一个key的不同field</li> <li>记录网站每个用户的个人主页访问量，可以使用哈希的自增hincrby
<ul><li>hincrby user:1:info pageview count</li></ul></li></ul></li> <li><p>Hash vs String</p> <ul><li>相似的API</li> <li>存储用户信息的三种方式，其中各用户包含的属性也不尽相同
<ul><li>使用String类型存储，String的key作为用户id，将各属性及对应的值序列化为json字符串，然后存入Redis，此方法缺点：序列化开销，修改属性时要操作整个数据</li> <li>使用String存储，用户id与不同的属性拼接后作为不同的key，不同key下存入不同的值，缺点：占用过多的键、内存占用较大；key比较分散，不好管理</li> <li>使用hash存储，用户id作为key，不同的属性作为field，不同field存储各value，比较直观，如果合理使用可以节省内存，但要控制hash在ziplist与hashtable两种编码的内部转换，编程稍微复杂</li></ul></li></ul></li> <li><p>Redis中hash的内部编码</p> <ul><li>ziplist（压缩列表）：当哈希类型元素的field个数小于hash-max-ziplist-entries配置(默认512各)，同时所有value值的大小都小于hash-max-ziplist-value配置(默认64字节)时，Redis会使用ziplist作为hash的内部实现，该结构更加紧凑，多个元素可以连续存储，更加节省内存</li> <li>hashtable（哈希表）：当hash类型不满足ziplist的条件时(field个数大于512或者有一个value值的大小大于64字节)，Redis会使用hashtable来作为hash'的内部实现，因为此时ziplist的读写效率会下降，而使用hashtable的读写时间复杂度为o(1)</li></ul></li></ul> <h3 id="列表"><a href="#列表" aria-hidden="true" class="header-anchor">#</a> 列表</h3> <p>列表(list)：是用来存储多个有序的字符串，列表中的每个元素称为元素(element)，一个列表中最多可以存储(2^32-1)各元素，可以对列表两端进行插入(push)或者弹出(pop)<img src="/assets/img/11.90ec6eb9.png" alt="列表"></p> <ol><li><p>特点</p> <ul><li>列表中的元素是有序的，可以通过索引下标获取某个元素或者某个范围的所有元素</li> <li>列表中的元素是可以重复的</li> <li>列表支持左右两边插入和弹出</li></ul></li> <li><p>重要API</p> <ol><li><p>添加元素</p> <ol><li><p>rpush：rpush key value1 value2 ... valueN从列表右边插入多个值(r代表right)，后插入的value在上一个值的右边，时间复杂度为o(n)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> rpush listkey value1 value2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
</code></pre></div></li> <li><p>lpush：lpush key value1 value2 ... valueN从列表左边插入多个值(l代表left)，后插入的value在上一个值的左边，时间复杂度为o(n)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> lpush listkey1 value3 value4
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey1 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value3&quot;</span>
</code></pre></div></li> <li><p>linsert：linsert key  before|after value newValue在list中指定的value值前或者后插入newValue，返回结果为当前列表的长度，时间复杂度为o(n)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> linsert listkey before value1 value3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value3&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> linsert listkey after value1 value4
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value3&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
</code></pre></div><p>如果linsert中指定的value值不存在，则插入失败，返回结果为-1</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> linsert listkey before value value5
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -1
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value3&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
</code></pre></div></li></ol></li> <li><p>查找</p> <ol><li><p>lrange：lrange key start end获取指定范围内的元素，start、end分别为元素的索引，从左到右看索引分别为0到N-1（正索引），也可以从右到左看，索引分别为-1到-N（负索引），而且正负索引可以混用（start下标不能为负，end下标可正可负）；第二，在Redis中的索引的结束下标包含了元素本身；第三，因为查询列表是从左往右查询，也就是从正着数第几个到倒着数第几个，如果end下标代表的元素在start下标代表元素的左边，则查询为空</p> <ul><li><p>查询所有元素：start下标为0，end下标为-1</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> rpush listkey value5 value6
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value3&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
5<span class="token punctuation">)</span> <span class="token string">&quot;value5&quot;</span>
6<span class="token punctuation">)</span> <span class="token string">&quot;value6&quot;</span>
</code></pre></div></li> <li><p>查询部分元素，start下标为0，如果end下标为正且超过列表长度(end&gt;N)，则也是查询出所有元素；如果end下标为负且小于列表长度(end&lt;-N)，则查询为空；等于-N，则查询第一个元素</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 8
1<span class="token punctuation">)</span> <span class="token string">&quot;value3&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
5<span class="token punctuation">)</span> <span class="token string">&quot;value5&quot;</span>
6<span class="token punctuation">)</span> <span class="token string">&quot;value6&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -6
1<span class="token punctuation">)</span> <span class="token string">&quot;value3&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -7
<span class="token punctuation">(</span>empty list or set<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>当start下标所代表的元素位于end所代表的的元素的右边时，查询也为空</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 3 2
<span class="token punctuation">(</span>empty list or set<span class="token punctuation">)</span>
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey -4 -5
<span class="token punctuation">(</span>empty list or set<span class="token punctuation">)</span>
</code></pre></div></li></ul></li> <li><p>lindex:lindex key index获取列表指定索引下标的元素，时间复杂度为o(n)</p></li> <li><p>llen:llen key获取列表的长度，时间复杂度为o(1)</p></li></ol></li> <li><p>删除：</p> <ol><li><p>lpop:lpop key从列表左侧弹出一个元素，返回值为弹出的元素</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value3&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
5<span class="token punctuation">)</span> <span class="token string">&quot;value5&quot;</span>
6<span class="token punctuation">)</span> <span class="token string">&quot;value6&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> lpop listkey
<span class="token string">&quot;value3&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;value5&quot;</span>
5<span class="token punctuation">)</span> <span class="token string">&quot;value6&quot;</span>
</code></pre></div></li> <li><p>rpop:rpop key从列表右侧弹出一个元素，返回值为弹出的元素</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> rpop listkey
<span class="token string">&quot;value6&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;value5&quot;</span>
</code></pre></div></li> <li><p>lrem:lrem key count value根据count值，从列表中删除所有与value相等的值，时间复杂度为o(n)</p> <ol><li>count&gt;0，从左往右删除最多count个与value值相等的项</li> <li>count&lt;0，从右往左删除最多-count个与value值相等的项</li> <li>count=0，删除所有与value相等的项</li></ol></li> <li><p>ltrim:ltrim key start end按照索引范围修剪列表，时间复杂度为o(n)
例如：只保留list中第二个到第四个元素ltrim listkey 1 3</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value1&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;value5&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> ltrim listkey 1 3
OK
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value5&quot;</span>
</code></pre></div></li></ol></li> <li><p>修改
lset:lset key index newValue设置指定索引下标的值为新的值，时间复杂度为o(n)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;value2&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value5&quot;</span>
127.0.0.1:6381<span class="token operator">&gt;</span> lset listkey 1 newValue
OK
127.0.0.1:6381<span class="token operator">&gt;</span> lrange listkey 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;value4&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;newValue&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;value5&quot;</span>
</code></pre></div></li> <li><p>阻塞操作:blpop、brpop是lpop和rpop的阻塞版本
blpop:blpop key [key1 key2...] timeout
brpop:brpop key [key1 key2...] timeout</p> <ul><li>如果列表为不为空，blpop/brpop会直接返回弹出的值，不会管timeout是多少，都会直接返回；如果是key有多个，该命令会从左到右遍历键，一旦有一个键能够弹出元素，则此命令直接返回</li> <li>如果列表为空，如果timeout不为零，该命令会阻塞timeout的秒数才返回，如果在此timeout超时时间内，该列表中添加了元素，则会立刻返回，否则会到timeout时间返回空值；如果timeout为0，则该命令会一直阻塞下去，直到该列表中添加了元素</li> <li>如果是多个客户端对同一个key执行blpop/brpop，那么最先执行该命令的客户端可以获取到弹出的值，其他客户端会被阻塞住</li></ul></li> <li><p>Tips:</p> <ol><li>lpush + lpop = stack</li> <li>lpush + rpop = queue</li> <li>lpush + ltrim = capped collection（固定长度的列表）</li> <li>lpush + brpop = message queue</li></ol></li></ol></li></ol> <h3 id="集合"><a href="#集合" aria-hidden="true" class="header-anchor">#</a> 集合</h3> <ol><li><p>特点:</p> <ol><li>集合中的元素是无序的，无法根据索引下标来查找元素</li> <li>不允许插入重复元素</li> <li>可以计算多个集合间的操作，比如交集、并集以及差集等</li></ol></li> <li><p>API:</p> <ol><li><p>添加元素:sadd key element向集合中添加元素，如果元素已存在，则添加失败</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> sadd setkey value
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6381<span class="token operator">&gt;</span> sadd setkey value
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
</code></pre></div></li> <li><p>删除元素:srem key element [element1...]移除元素,可以同时删除多个元素</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> srem setkey value
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6381<span class="token operator">&gt;</span> srem setkey value
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
</code></pre></div></li> <li><p>计算元素个数:scard key,时间复杂度为o(1),不会遍历集合内的所有元素，会直接返回元素个数的变量</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> sadd setkey value
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6381<span class="token operator">&gt;</span> scard setkey
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6381<span class="token operator">&gt;</span> sadd setkey value1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6381<span class="token operator">&gt;</span> scard setkey
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
</code></pre></div></li> <li><p>判断元素是否位于集合中:sismember key element,如果存在返回1,否则返回0</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> sismember setkey value1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6381<span class="token operator">&gt;</span> sismember setkey value2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
</code></pre></div></li> <li><p>随机从集合中返回元素:srandmember key [count],其中count是可选参数,随机从集合中返回元素的个数,默认为1</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> srandmember setkey
</code></pre></div></li></ol></li></ol> <p>&quot;value&quot;
127.0.0.1:6381&gt; srandmember setkey
&quot;value5&quot;
127.0.0.1:6381&gt; srandmember setkey 2</p> <ol><li><p>&quot;value3&quot;</p></li> <li><p>&quot;value4&quot;
```</p> <ol start="6"><li><p>随机从集合中弹出元素:spop key,从Redis3.2开始,spop也支持count选项</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> spop setkey
<span class="token string">&quot;value5&quot;</span>
</code></pre></div></li> <li><p>获取所有元素:smembers key</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> smembers setkey
</code></pre></div></li></ol> <ol><li>&quot;value&quot;</li> <li>&quot;value3&quot;</li> <li>&quot;value4&quot;</li> <li>&quot;value1&quot;<div class="language- extra-class"><pre class="language-text"><code>
</code></pre></div></li></ol></li></ol> <ol><li>计算两个集合之间的交集、并集、差集等</li></ol> <h3 id="有序集合"><a href="#有序集合" aria-hidden="true" class="header-anchor">#</a> 有序集合</h3> <ol><li><p>有序集合结构特点</p> <ol><li>保留了集合中不能存在重复元素的特点</li> <li>有序集合中的元素可以排序，但不是使用的是索引下标，而是给每个元素设置了一个分数score作为排序的依据<img src="/assets/img/12.74b9b67a.png" alt=""></li> <li>集合中的元素不能重复，但是score是可以重复的</li> <li>列表、集合与有序集合的区别<img src="/assets/img/13.a024676e.png" alt="列表、集合与有序集合的区别"></li></ol></li> <li><p>API</p> <ol><li><p>zadd key score value [score1 value1]...添加元素，返回结果代表添加元素的个数，时间复杂度为o(logN)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>127.0.0.1:6381<span class="token operator">&gt;</span> zadd zsetkey 12 value1 14 value2 25 value3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
</code></pre></div></li> <li><p>zrem key element [element1]... 删除元素，时间复杂度为o(1)，返回结果为删除元素的个数</p></li> <li><p>zscore key element 返回元素的分数</p></li> <li><p>zcard key 返回元素的个数，时间复杂度为o(1)</p></li> <li><p>zincrby key increment member：增加元素的分数，increment为要增加的分数值</p></li> <li><p>zrank/zrevrank：zrank key element：返回从低到高/从高到低的分数排名，排名从0开始</p></li> <li><p>zrange/zrevrange：zrange key start end [withscores]：返回特定排名范围内的元素：zrange从低到高排名，zrerange从高到低排名，start、end分别是排名的下标，且包含结束下标，且下标可以为负，如果加上withscores选项，同时会返回成员的分数</p></li> <li><p>zrangebyscore key min max [withscores] [limit offset count]：返回特定分数范围内的元素，min为最小分数，max为最大分数，[limit offset count]选项可以限制输出的起始位置和个数</p></li> <li><p>zcount key min max：返回指定分数范围内元素个数</p></li></ol></li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2019-7-13 2:31:14 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/后端/Redis/Redis从入门到高可用分布式实践/Redis初识/Redis初识.html" class="prev">Redis初识</a></span> <span class="next"><a href="/后端/Redis/Redis从入门到高可用分布式实践/Redis客户端/Redis客户端.html">Redis客户端</a>→
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.2ed4a716.js" defer></script><script src="/assets/js/2.0d3085da.js" defer></script><script src="/assets/js/4.6eb19324.js" defer></script>
  </body>
</html>
