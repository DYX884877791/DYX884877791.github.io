<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java线程池 | 吃饭睡觉打豆豆</title>
    <meta name="description" content=" ">
    <link rel="icon" href="/favicon.png">
  <link rel="manifest" href="/images/pic.jpg">
  <link rel="apple-touch-icon" href="/images/pic.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    
    <link rel="preload" href="/assets/css/0.styles.0f5aefa9.css" as="style"><link rel="preload" href="/assets/js/app.2ed4a716.js" as="script"><link rel="preload" href="/assets/js/2.0d3085da.js" as="script"><link rel="preload" href="/assets/js/31.4f595fb1.js" as="script"><link rel="prefetch" href="/assets/js/10.56332b24.js"><link rel="prefetch" href="/assets/js/11.dc70378b.js"><link rel="prefetch" href="/assets/js/12.c27a5cc7.js"><link rel="prefetch" href="/assets/js/13.cd445f8c.js"><link rel="prefetch" href="/assets/js/14.a519b732.js"><link rel="prefetch" href="/assets/js/15.71d77324.js"><link rel="prefetch" href="/assets/js/16.2282c2e6.js"><link rel="prefetch" href="/assets/js/17.84ef61f7.js"><link rel="prefetch" href="/assets/js/18.f341b90a.js"><link rel="prefetch" href="/assets/js/19.28081019.js"><link rel="prefetch" href="/assets/js/20.400cb076.js"><link rel="prefetch" href="/assets/js/21.54d5f8e0.js"><link rel="prefetch" href="/assets/js/22.302d416f.js"><link rel="prefetch" href="/assets/js/23.bcb3ed03.js"><link rel="prefetch" href="/assets/js/24.7b575690.js"><link rel="prefetch" href="/assets/js/25.eef0e9ab.js"><link rel="prefetch" href="/assets/js/26.e5319516.js"><link rel="prefetch" href="/assets/js/27.7a39b9af.js"><link rel="prefetch" href="/assets/js/28.53ab4bfa.js"><link rel="prefetch" href="/assets/js/29.6da66f35.js"><link rel="prefetch" href="/assets/js/3.579889d3.js"><link rel="prefetch" href="/assets/js/30.7ce82f78.js"><link rel="prefetch" href="/assets/js/32.4ea77839.js"><link rel="prefetch" href="/assets/js/33.7fa19738.js"><link rel="prefetch" href="/assets/js/34.ca110b46.js"><link rel="prefetch" href="/assets/js/35.af16c3a0.js"><link rel="prefetch" href="/assets/js/36.146105e1.js"><link rel="prefetch" href="/assets/js/37.a725ceea.js"><link rel="prefetch" href="/assets/js/38.cadf49e9.js"><link rel="prefetch" href="/assets/js/39.537fbddf.js"><link rel="prefetch" href="/assets/js/4.6eb19324.js"><link rel="prefetch" href="/assets/js/40.e9f8e128.js"><link rel="prefetch" href="/assets/js/41.19f8fb66.js"><link rel="prefetch" href="/assets/js/42.0a39bbea.js"><link rel="prefetch" href="/assets/js/43.0ed9d746.js"><link rel="prefetch" href="/assets/js/44.89f92846.js"><link rel="prefetch" href="/assets/js/45.2e313083.js"><link rel="prefetch" href="/assets/js/46.a4cc6906.js"><link rel="prefetch" href="/assets/js/47.7061b060.js"><link rel="prefetch" href="/assets/js/48.d40e2261.js"><link rel="prefetch" href="/assets/js/49.07b001ce.js"><link rel="prefetch" href="/assets/js/5.b5ba2def.js"><link rel="prefetch" href="/assets/js/50.5b6f7890.js"><link rel="prefetch" href="/assets/js/51.23496ee3.js"><link rel="prefetch" href="/assets/js/52.687b8402.js"><link rel="prefetch" href="/assets/js/53.c79069f6.js"><link rel="prefetch" href="/assets/js/54.69c422ad.js"><link rel="prefetch" href="/assets/js/55.0b2eddb9.js"><link rel="prefetch" href="/assets/js/56.a908f57d.js"><link rel="prefetch" href="/assets/js/57.c1b2dbbd.js"><link rel="prefetch" href="/assets/js/58.07a79fec.js"><link rel="prefetch" href="/assets/js/59.0e076c5f.js"><link rel="prefetch" href="/assets/js/6.6725e2bb.js"><link rel="prefetch" href="/assets/js/60.45e33df3.js"><link rel="prefetch" href="/assets/js/61.8aca7760.js"><link rel="prefetch" href="/assets/js/62.302ed63d.js"><link rel="prefetch" href="/assets/js/63.097511c4.js"><link rel="prefetch" href="/assets/js/64.a9c1111f.js"><link rel="prefetch" href="/assets/js/65.5c7e6580.js"><link rel="prefetch" href="/assets/js/66.4d31114d.js"><link rel="prefetch" href="/assets/js/67.a9492502.js"><link rel="prefetch" href="/assets/js/68.0faaaa93.js"><link rel="prefetch" href="/assets/js/69.bfbae9d0.js"><link rel="prefetch" href="/assets/js/7.5d32872a.js"><link rel="prefetch" href="/assets/js/8.63ab5f4b.js"><link rel="prefetch" href="/assets/js/9.a0ac733d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0f5aefa9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">吃饭睡觉打豆豆</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">BackEnd</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/后端/Java/JavaSE/变量.html" class="nav-link">JavaSE</a></li><li class="dropdown-subitem"><a href="/后端/Java/JavaEE/" class="nav-link">JavaEE</a></li></ul></li><li class="dropdown-item"><!----> <a href="/后端/Redis/Redis从入门到高可用分布式实践/目录说明.html" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/后端/Kafka/Kafka原理介绍.html" class="nav-link">Kafka</a></li><li class="dropdown-item"><!----> <a href="/后端/Python/" class="nav-link">Python</a></li><li class="dropdown-item"><h4>Spring</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/后端/Spring源码解析/Spring源码解析.html" class="nav-link">Spring源码解析</a></li></ul></li><li class="dropdown-item"><h4>Linux</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/linux/" class="nav-link">Linux</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">FrontEnd</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/frontend/" class="nav-link">Frontend</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/数据结构与算法/数据结构不难/" class="nav-link">数据结构不难</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/算法很美/" class="nav-link">算法很美</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">大数据</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/大数据/Hadoop/README.html" class="nav-link">Hadoop</a></li></ul></div></div> <a href="https://github.com/DYX884877791/DYX884877791.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">BackEnd</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/后端/Java/JavaSE/变量.html" class="nav-link">JavaSE</a></li><li class="dropdown-subitem"><a href="/后端/Java/JavaEE/" class="nav-link">JavaEE</a></li></ul></li><li class="dropdown-item"><!----> <a href="/后端/Redis/Redis从入门到高可用分布式实践/目录说明.html" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/后端/Kafka/Kafka原理介绍.html" class="nav-link">Kafka</a></li><li class="dropdown-item"><!----> <a href="/后端/Python/" class="nav-link">Python</a></li><li class="dropdown-item"><h4>Spring</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/后端/Spring源码解析/Spring源码解析.html" class="nav-link">Spring源码解析</a></li></ul></li><li class="dropdown-item"><h4>Linux</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/linux/" class="nav-link">Linux</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">FrontEnd</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/frontend/" class="nav-link">Frontend</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/数据结构与算法/数据结构不难/" class="nav-link">数据结构不难</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/算法很美/" class="nav-link">算法很美</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">大数据</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/大数据/Hadoop/README.html" class="nav-link">Hadoop</a></li></ul></div></div> <a href="https://github.com/DYX884877791/DYX884877791.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/" class="sidebar-link">首页</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaSE</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>IO</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>多线程与JUC</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/后端/Java/JavaSE/多线程与JUC/volatile与内存可见性.html" class="sidebar-link">Java中的volatile关键字</a></li><li><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html" class="active sidebar-link">Java线程池</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#线程池executor框架" class="sidebar-link">线程池Executor框架</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#executor接口" class="sidebar-link">Executor接口</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#executorservice接口" class="sidebar-link">ExecutorService接口</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#scheduledexecutorservice接口" class="sidebar-link">ScheduledExecutorService接口</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#threadpoolexecutor类" class="sidebar-link">ThreadPoolExecutor类</a></li></ul></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#threadpoolexecutor各参数详解" class="sidebar-link">ThreadPoolExecutor各参数详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#corepoolsize" class="sidebar-link">corePoolSize</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#maximumpoolsize" class="sidebar-link">maximumPoolSize</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#keepalivetime" class="sidebar-link">keepAliveTime</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#unit" class="sidebar-link">unit</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#workqueue" class="sidebar-link">workQueue</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#threadfactory" class="sidebar-link">ThreadFactory</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#handler" class="sidebar-link">handler</a></li></ul></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#jdk自带的线程池" class="sidebar-link">JDK自带的线程池</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#newfixedthreadpool-int-nthreads" class="sidebar-link">newFixedThreadPool(int nThreads)</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#newsinglethreadexecutor" class="sidebar-link">newSingleThreadExecutor()</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#newcachedthreadpool" class="sidebar-link">newCachedThreadPool()</a></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#newscheduledthreadpool" class="sidebar-link">newScheduledThreadPool()</a></li></ul></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#线程池的常用函数" class="sidebar-link">线程池的常用函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#关闭线程池" class="sidebar-link">关闭线程池</a></li></ul></li><li class="sidebar-sub-header"><a href="/后端/Java/JavaSE/多线程与JUC/线程池.html#reference" class="sidebar-link">Reference</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java线程池"><a href="#java线程池" aria-hidden="true" class="header-anchor">#</a> Java线程池</h1> <p></p><div class="table-of-contents"><ul><li><a href="#线程池executor框架">线程池Executor框架</a><ul><li><a href="#executor接口">Executor接口</a></li><li><a href="#executorservice接口">ExecutorService接口</a></li><li><a href="#scheduledexecutorservice接口">ScheduledExecutorService接口</a></li><li><a href="#threadpoolexecutor类">ThreadPoolExecutor类</a></li></ul></li><li><a href="#threadpoolexecutor各参数详解">ThreadPoolExecutor各参数详解</a><ul><li><a href="#corepoolsize">corePoolSize</a></li><li><a href="#maximumpoolsize">maximumPoolSize</a></li><li><a href="#keepalivetime">keepAliveTime</a></li><li><a href="#unit">unit</a></li><li><a href="#workqueue">workQueue</a></li><li><a href="#threadfactory">ThreadFactory</a></li><li><a href="#handler">handler</a></li></ul></li><li><a href="#jdk自带的线程池">JDK自带的线程池</a><ul><li><a href="#newfixedthreadpool-int-nthreads">newFixedThreadPool(int nThreads)</a></li><li><a href="#newsinglethreadexecutor">newSingleThreadExecutor()</a></li><li><a href="#newcachedthreadpool">newCachedThreadPool()</a></li><li><a href="#newscheduledthreadpool">newScheduledThreadPool()</a></li></ul></li><li><a href="#线程池的常用函数">线程池的常用函数</a><ul><li><a href="#关闭线程池">关闭线程池</a></li></ul></li><li><a href="#reference">Reference</a></li></ul></div><p></p> <h2 id="线程池executor框架"><a href="#线程池executor框架" aria-hidden="true" class="header-anchor">#</a> 线程池Executor框架</h2> <p><img src="assets/ExecutorFramework.png" alt=""></p> <h3 id="executor接口"><a href="#executor接口" aria-hidden="true" class="header-anchor">#</a> Executor接口</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Executor接口只有一个execute方法，用来替代通常创建或启动线程的方法。例如，使用Thread来创建并启动线程的代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用Executor来启动线程执行任务的代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>对于不同的Executor实现，execute()方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程。</p> <h3 id="executorservice接口"><a href="#executorservice接口" aria-hidden="true" class="header-anchor">#</a> ExecutorService接口</h3> <p>ExecutorService接口继承自Executor接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。增加了shutDown()，shutDownNow()，invokeAll()，invokeAny()和submit()等方法。如果需要支持即时关闭，也就是shutDownNow()方法，则任务需要正确处理中断。</p> <h3 id="scheduledexecutorservice接口"><a href="#scheduledexecutorservice接口" aria-hidden="true" class="header-anchor">#</a> ScheduledExecutorService接口</h3> <p>ScheduledExecutorService扩展ExecutorService接口并增加了schedule方法。调用schedule方法可以在指定的延时后执行一个Runnable或者Callable任务。ScheduledExecutorService接口还定义了按照指定时间间隔定期执行任务的scheduleAtFixedRate()方法和scheduleWithFixedDelay()方法。</p> <h3 id="threadpoolexecutor类"><a href="#threadpoolexecutor类" aria-hidden="true" class="header-anchor">#</a> ThreadPoolExecutor类</h3> <p>ThreadPoolExecutor继承自AbstractExecutorService，同时实现了ExecutorService接口。</p> <p>先了解<code>ThreadPoolExecutor</code>这个类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 代表线程池当前状态和线程数量的原子变量</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// COUNT_BITS为29</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//CAPACITY为能表示的最大线程数。</span>
<span class="token comment">// 线程池状态</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>

<span class="token comment">// 对线程池状态和线程数量进行打包和拆包的函数：</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment">// 判断线程池状态的三个函数</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">runStateLessThan</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&lt;</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&gt;=</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&lt;</span> SHUTDOWN<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 线程数量增1，成功返回true，失败返回false</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>expect<span class="token punctuation">,</span> expect <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token comment">// 线程数量减1，成功返回true，失败返回false</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>expect<span class="token punctuation">,</span> expect <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 线程数量减1，失败则重试直到成功</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>ctl是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。</p> <p>下面再介绍下线程池的运行状态. 线程池一共有五种状态, 分别是:</p> <ul><li>RUNNING ：高3位为<em>111</em>，该状态的线程池能接受新提交的任务，并且也能处理阻塞队列中的任务；</li> <li>SHUTDOWN：高3位为<em>000</em>，该状态的线程池处于关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；</li> <li>STOP：高3位为<em>001</em>，该状态的线程池不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；</li> <li>TIDYING：高3位为<em>010</em>，当线程池关闭后阻塞队列的任务已完成或线程池停止，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。</li> <li>TERMINATED：高3位为011，在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。
进入TERMINATED的条件如下：
<ul><li>线程池不是RUNNING状态；</li> <li>线程池状态不是TIDYING状态或TERMINATED状态；</li> <li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li> <li>workerCount为0；</li> <li>设置TIDYING状态成功。</li></ul></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//线程池配置信息，volatile修饰保证变量在多线程下的可见性</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> corePoolSize<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">RejectedExecutionHandler</span> defaultHandler <span class="token operator">=</span>
    <span class="token keyword">new</span> <span class="token class-name">AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">RuntimePermission</span> shutdownPerm <span class="token operator">=</span>
    <span class="token keyword">new</span> <span class="token class-name">RuntimePermission</span><span class="token punctuation">(</span><span class="token string">&quot;modifyThread&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>
            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>
            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre></div><p><code>ThreadPoolExecutor</code>类中有四个重载的构造函数，每个构造函数都必须指定上表中的前5个参数，最后两个参数可以随意指定，不指定的话构造函数会使用默认的<strong>线程工厂</strong>和<strong>饱和策略</strong>：</p> <table><thead><tr><th>参数</th> <th>含义</th></tr></thead> <tbody><tr><td>corePoolSize</td> <td>基本大小，即线程池中的核心线程数</td></tr> <tr><td>maximumPoolSize</td> <td>最大大小，即线程池中允许的最大线程数</td></tr> <tr><td>keepAliveTime</td> <td>存活时间，当线程的没执行任务时，空闲的时间超过了这个时间就会被标记为可回收，直到线程池的大小超过基本大小，被标记的线程就会被终止</td></tr> <tr><td>unit</td> <td>keepAliveTime的单位，有DAYS、HOURS、MINUTES、SECONDS、MILLISECONDS、MICROSECONDS、NANOSECONDS7个单位可选</td></tr> <tr><td>workQueue</td> <td>工作队列，一个用来保存等待被执行的任务的阻塞队列</td></tr> <tr><td>threadFactory</td> <td>线程工厂。线程池在创建线程时通过调用线程工厂的<code>Thread newThread(Runnable r)</code>来创建线程</td></tr> <tr><td>handler</td> <td>饱和策略。当阻塞队列已满、线程池当前的线程数已达到最大值且没有线程处于空闲状态时，此时对于提交过来的任务将执行饱和策略。（如果某个任务提交到一个已关闭的Executor时，也会执行饱和策略）</td></tr></tbody></table> <h2 id="threadpoolexecutor各参数详解"><a href="#threadpoolexecutor各参数详解" aria-hidden="true" class="header-anchor">#</a> ThreadPoolExecutor各参数详解</h2> <h3 id="corepoolsize"><a href="#corepoolsize" aria-hidden="true" class="header-anchor">#</a> corePoolSize</h3> <p>核心线程数，即线程池中一直存活着的线程的最小数量。需要注意的是，核心线程数并不代表线程池启动后，就会立即创建这么多线程，只有当线程池接收到我们提交给他的任务后, 它才会去创建并启动一定数量的核心线程来执行这些任务。<strong>除非调用prestartAllCoreThreads或者prestartCoreThread这两个方法，这两个方法分别是在无任务到来之前预创建所有核心线程或者创建一个线程</strong>。这种默认的核心线程的创建启动机制，有助于降低系统资源的消耗。</p> <p>线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的线程不是核心线程。核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。如果指定ThreadPoolExecutor的<code>allowCoreThreadTimeOut</code>这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间(时长下面参数决定)，就会被销毁掉。</p> <p>如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务。</p> <p>如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理。</p> <p>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务。</p> <p>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</p> <h3 id="maximumpoolsize"><a href="#maximumpoolsize" aria-hidden="true" class="header-anchor">#</a> maximumPoolSize</h3> <p>线程池中允许创建的最大线程数量，当线程池的当前的核心线程全部在运行中，此时线程池接收到新的执行任务后，首先会判断线程池内部的阻塞队列 workQueue 中是否还有空间，如果有，则会将任务放入阻塞队列中，否则，会创建新的线程去进行执行；当线程数达到了最大线程数后，线程池接收到新的任务后，将会触发拒绝策略。</p> <h3 id="keepalivetime"><a href="#keepalivetime" aria-hidden="true" class="header-anchor">#</a> keepAliveTime</h3> <p>当线程池中的线程数大于核心线程数时，如果一个线程处于空闲状态，超过keepAliveTime 时间将终止该线程。这个参数的设定，需要考虑具体情况：如果要执行的任务相对较多，并且每个任务执行的时间比较短，那么可以为该参数设置一个相对较大的数值，以提高线程的利用率。</p> <p>如果执行的任务相对较少, 线程池使用率相对较低, 那么可以先将该参数设置为一个较小的数值, 通过超时停止的机制来降低系统线程资源的开销, 后续如果发现线程池的使用率逐渐增高以后, 线程池会根据当前提交的任务数自动创建新的线程。</p> <h3 id="unit"><a href="#unit" aria-hidden="true" class="header-anchor">#</a> unit</h3> <p>keepAliveTime的时间单位。</p> <h3 id="workqueue"><a href="#workqueue" aria-hidden="true" class="header-anchor">#</a> workQueue</h3> <p>一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列、延迟队列等</p> <h4 id="synchronousqueue"><a href="#synchronousqueue" aria-hidden="true" class="header-anchor">#</a> SynchronousQueue</h4> <p>SynchronousQueue（直接提交队列）是一个特殊的BlockingQueue，它没有容量，每执行一个插入操作就会阻塞，需要再执行一个删除操作才会被唤醒，反之每一个删除操作也都要等待对应的插入操作。使用SynchronousQueue队列，提交的任务不会被保存到队列中，如果用于执行任务的线程数量小于maximumPoolSize，则尝试创建新的进程，马上提交执行；如果达到maximumPoolSize设置的最大值，则根据你设置的handler执行拒绝策略。在这种情况下，需要对你程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量，否则很容易就会执行拒绝策略；吞吐量通常要高于LinkedBlockingQueue。</p> <h4 id="arrayblockingqueue"><a href="#arrayblockingqueue" aria-hidden="true" class="header-anchor">#</a> ArrayBlockingQueue</h4> <p>ArrayBlockingQueue（有界任务队列）是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。若有新的任务提交到线程池时，如果当前数量小于corePoolSize，则会创建新的线程，直到达到corePoolSize，否则会直接加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程，直到线程数量达到maximumPoolSize设置的最大线程数量，若大于maximumPoolSize，则执行拒绝策略。在这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界队列初始容量较大或者没有达到超负荷的状态，线程数将一直维持在corePoolSize以下，反之当任务队列已满时，则会以maximumPoolSize为最大线程数上限。</p> <h4 id="linkedblockingqueue"><a href="#linkedblockingqueue" aria-hidden="true" class="header-anchor">#</a> LinkedBlockingQueue</h4> <p>LinkedBlockingQueue（无界任务队列）是一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，线程池的任务队列可以无限制的添加新的任务，而线程池创建的最大线程数量就是你corePoolSize设置的数量，LinkedBlockingQueue的容量最大值为Integet.MAX，也就是说在这种情况下maximumPoolSize这个参数是无效的，哪怕你的任务队列中缓存了很多未执行的任务，当线程池的线程数达到corePoolSize后，就不会再增加了；若后续有新的任务加入，则直接进入队列等待，当使用这种任务队列模式时，一定要注意你任务提交与处理之间的协调与控制，不然会出现队列中的任务由于无法及时处理导致一直增长，直到最后资源耗尽的问题。吞吐量通常要高于ArrayBlockingQueue。</p> <h4 id="priorityblockingqueue"><a href="#priorityblockingqueue" aria-hidden="true" class="header-anchor">#</a> PriorityBlockingQueue</h4> <p>PriorityBlockingQueue（优先任务队列）是一个特殊的无界队列，它其中无论添加了多少个任务，线程池创建的线程数也不会超过corePoolSize的数量，只不过其他队列一般是按照先进先出的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。</p> <h4 id="delayqueue"><a href="#delayqueue" aria-hidden="true" class="header-anchor">#</a> DelayQueue</h4> <p>DelayQueue（延迟队列）是一个存放实现Delayed接口的数据的无界阻塞队列，只有当数据对象的延时时间达到时才能插入到队列进行存储。一个任务定时周期的延迟执行的队列，根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。</p> <h3 id="threadfactory"><a href="#threadfactory" aria-hidden="true" class="header-anchor">#</a> ThreadFactory</h3> <p>线程池创建线程都是通过的<code>ThreadFactory</code>的<code>Thread newThread(Runnable r)</code>方法来创建的。下面是<code>Executors</code>类里的默认线程工厂方法的源码。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>
   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> poolNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ThreadGroup</span> group<span class="token punctuation">;</span>
   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> threadNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> namePrefix<span class="token punctuation">;</span>

   <span class="token class-name">DefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">SecurityManager</span> s <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      group <span class="token operator">=</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> s<span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>
      <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      namePrefix <span class="token operator">=</span> <span class="token string">&quot;pool-&quot;</span> <span class="token operator">+</span>
         poolNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
         <span class="token string">&quot;-thread-&quot;</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> r<span class="token punctuation">,</span>
                            namePrefix <span class="token operator">+</span> threadNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                            <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span>
         t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> t<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上面可以看出默认线程工厂创建出的是一个<strong>非守护、优先级为Thread.NORM_PRIORITY</strong> 的线程。如果想要自己定制线程工厂满足需求，只需实现<code>ThreadFactory</code>接口的<code>Thread newThread(Runnable r)</code>方法。</p> <h3 id="handler"><a href="#handler" aria-hidden="true" class="header-anchor">#</a> handler</h3> <h4 id="rejectedexecutionhandler接口"><a href="#rejectedexecutionhandler接口" aria-hidden="true" class="header-anchor">#</a> RejectedExecutionHandler接口</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>拒绝策略，当向线程池提交新的任务，线程池无法执行的时候，将会触发拒绝策略。当出现以下情况时，拒绝策略将会触发：</p> <ul><li>当线程池处于SHUTDOWN状态时</li> <li>当线程池的线程数已达到最大线程数且全部为运行状态，同时阻塞队列的容量已满</li></ul> <p>ThreadPoolExecutor支持四种拒绝策略，分别是：</p> <h4 id="abortpolicy"><a href="#abortpolicy" aria-hidden="true" class="header-anchor">#</a> AbortPolicy</h4> <p>直接拒绝策略，抛出 RejectedExecutionException 异常，该策略也是线程池的默认拒绝策略</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AbortPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token class-name">AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span><span class="token string">&quot;Task &quot;</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                                           <span class="token string">&quot; rejected from &quot;</span> <span class="token operator">+</span>
                                           e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 该策略 直接抛出了异常。异常中止</span>
</code></pre></div><h4 id="callerrunspolicy"><a href="#callerrunspolicy" aria-hidden="true" class="header-anchor">#</a> CallerRunsPolicy</h4> <p>将被拒绝的任务放在ThreadPoolExecutor.execute()方法所在的那个线程中执行。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CallerRunsPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 直接在当前线程执行任务。所谓当前线程，即提交任务时的线程，即调用 ThreadPoolExecutor#execute()的线程。</span>
</code></pre></div><h4 id="discardpolicy"><a href="#discardpolicy" aria-hidden="true" class="header-anchor">#</a> DiscardPolicy</h4> <p>将被拒绝的任务直接删除</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">DiscardPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 丢弃新任务。不做任何处理，跳过任务r</span>
</code></pre></div><h4 id="discardoldestpolicy"><a href="#discardoldestpolicy" aria-hidden="true" class="header-anchor">#</a> DiscardOldestPolicy</h4> <p>当线程池没有关闭的情况下，会将阻塞队列队首的那个任务从队列中移除，然后将被拒绝的任务加入队列的队尾</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardOldestPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">DiscardOldestPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 在线程池未关闭时，移除处于队头的任务，再执行任务r。相当于把之前队头的任务跳过了，把r又加入了队列</span>
</code></pre></div><h2 id="jdk自带的线程池"><a href="#jdk自带的线程池" aria-hidden="true" class="header-anchor">#</a> JDK自带的线程池</h2> <p>Executors提供了四种静态工厂方法来创建四种不同配置的线程池：</p> <h3 id="newfixedthreadpool-int-nthreads"><a href="#newfixedthreadpool-int-nthreads" aria-hidden="true" class="header-anchor">#</a> newFixedThreadPool(int nThreads)</h3> <p>接受一个int类型的nThreads变量，创建一个核心线程数和最大线程数都为nThreads的线程池（即最大线程数为nThreads），且使用一个无界的阻塞队列LinkedBlockingQueue。如果不设置核心线程超时的话，创建的线程是不会超时的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="特点"><a href="#特点" aria-hidden="true" class="header-anchor">#</a> 特点</h4> <ul><li>核心线程数和最大线程数大小一样</li> <li>没有所谓的非空闲时间，即keepAliveTime为0</li> <li>阻塞队列为无界队列LinkedBlockingQueue</li></ul> <p>newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，一旦有大量的任务提交到线程池时，会导致队列的任务越积越多，导致机器内存使用不停飙升， 最终导致OOM。</p> <h4 id="使用场景"><a href="#使用场景" aria-hidden="true" class="header-anchor">#</a> 使用场景</h4> <p>FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p> <h3 id="newsinglethreadexecutor"><a href="#newsinglethreadexecutor" aria-hidden="true" class="header-anchor">#</a> newSingleThreadExecutor()</h3> <p>创建一个核心线程数和最大线程数都为1的线程池（即最大线程数为1)，且使用一个无界的阻塞队列LinkedBlockingQueue，不设置核心线程超时的话，创建的线程也是不会超时的。唯一线程可以保证任务的顺序执行，如果这个唯一的线程执行过程中因为异常而结束的话，在processWorkerExit方法最后会判断是否因异常而结束而创建一个新线程继续运行。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>
        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
                                <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="特点-2"><a href="#特点-2" aria-hidden="true" class="header-anchor">#</a> 特点</h4> <ul><li>核心线程数为1</li> <li>最大线程数也为1</li> <li>阻塞队列是LinkedBlockingQueue</li> <li>keepAliveTime为0</li></ul> <h4 id="使用场景-2"><a href="#使用场景-2" aria-hidden="true" class="header-anchor">#</a> 使用场景</h4> <p>适用于串行执行任务的场景，一个任务一个任务地执行。</p> <h3 id="newcachedthreadpool"><a href="#newcachedthreadpool" aria-hidden="true" class="header-anchor">#</a> newCachedThreadPool()</h3> <p>创建一个核心线程数为0，最大线程数为Integer.MAX_VALUE的线程池，超时时间为60秒，所以线程空闲时间超过60秒就会被回收。使用了一个同步队列作为阻塞队列，同步队列不存储元素，且在一端进行插入，另一端要有移除操作插入才会成功，否则插入操作会阻塞等待。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>
                                  <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>
                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="特点："><a href="#特点：" aria-hidden="true" class="header-anchor">#</a> 特点：</h4> <ul><li>核心线程数为0</li> <li>最大线程数为Integer.MAX_VALUE</li> <li>阻塞队列是SynchronousQueue</li> <li>非核心线程空闲存活时间为60秒</li></ul> <p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p> <h4 id="适用场景"><a href="#适用场景" aria-hidden="true" class="header-anchor">#</a> 适用场景</h4> <p>用于并发执行大量短期的小任务。</p> <h3 id="newscheduledthreadpool"><a href="#newscheduledthreadpool" aria-hidden="true" class="header-anchor">#</a> newScheduledThreadPool()</h3> <p>创建一个核心线程数为corePoolSize的线程池，用于指定的时间内周期性的执行所的任务。ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="特点-3"><a href="#特点-3" aria-hidden="true" class="header-anchor">#</a> 特点</h4> <ul><li>最大线程数为Integer.MAX_VALUE</li> <li>阻塞队列是DelayedWorkQueue</li> <li>keepAliveTime为0</li> <li>scheduleAtFixedRate() ：按某种速率周期执行</li> <li>scheduleWithFixedDelay()：在某个延迟后执行</li></ul> <h4 id="使用场景-3"><a href="#使用场景-3" aria-hidden="true" class="header-anchor">#</a> 使用场景</h4> <p>周期性执行任务的场景，需要限制线程数量的场景</p> <h2 id="线程池的常用函数"><a href="#线程池的常用函数" aria-hidden="true" class="header-anchor">#</a> 线程池的常用函数</h2> <h3 id="关闭线程池"><a href="#关闭线程池" aria-hidden="true" class="header-anchor">#</a> 关闭线程池</h3> <p>线程池提供两种关闭线程池方法：shutDown()和shutdownNow()</p> <h4 id="shutdown"><a href="#shutdown" aria-hidden="true" class="header-anchor">#</a> shutDown()</h4> <p>当线程池调用该方法时,线程池的状态则立刻变成SHUTDOWN状态。此时，则不能再往线程池中添加任何任务，否则将会抛出RejectedExecutionException异常。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。</p> <h4 id="shutdownnow"><a href="#shutdownnow" aria-hidden="true" class="header-anchor">#</a> shutdownNow()</h4> <p>根据JDK文档描述，大致意思是：执行该方法，线程池的状态立刻变成STOP状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。
它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有sleep、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。</p> <h2 id="reference"><a href="#reference" aria-hidden="true" class="header-anchor">#</a> Reference</h2> <p><a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">深入理解Java线程池：ThreadPoolExecutor<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.infoq.cn/article/java-threadPool/" target="_blank" rel="noopener noreferrer">聊聊并发（三）——JAVA 线程池的分析和使用<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.im/post/5aedb6b651882522835e5e45" target="_blank" rel="noopener noreferrer">线程池你真不来了解一下吗？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://segmentfault.com/a/1190000018399962" target="_blank" rel="noopener noreferrer">Java 线程池的认识和使用<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.im/post/5c96de2ce51d451f9e360edc" target="_blank" rel="noopener noreferrer">从0到1玩转线程池<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/后端/Java/JavaSE/多线程与JUC/volatile与内存可见性.html" class="prev">Java中的volatile关键字</a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.2ed4a716.js" defer></script><script src="/assets/js/2.0d3085da.js" defer></script><script src="/assets/js/31.4f595fb1.js" defer></script>
  </body>
</html>
