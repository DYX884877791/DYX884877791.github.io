(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{299:function(a,e,t){"use strict";t.r(e);var n=t(0),r=Object(n.a)({},function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"java注解与xml配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java注解与xml配置","aria-hidden":"true"}},[a._v("#")]),a._v(" Java注解与XML配置")]),a._v(" "),t("h2",{attrs:{id:"java的注解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java的注解","aria-hidden":"true"}},[a._v("#")]),a._v(" Java的注解")]),a._v(" "),t("p",[a._v("注解是在jdk1.5以后引入的新特性！有利于代码的解藕、整洁，提升开发的效率！通俗来讲，注解就是标签，标签的内容可以变动！\n注解也是java中的一种数据类型！注解的创建和接口的创建很类似！使用@Interface修饰！既然说到注解了，就要说到jdk本身自带的几种原生注解！这是原生注解是用于修饰自定义注解！如果自定义注解没有这些原生注解修饰，自定义注解不能正常工作使用！\n目前，jdk自带的原生注解有6个：\n@Retention , @Target , @Inherited , @Documented , @Repeatable , @Native\n其中，@Native、@Repeabable是在jdk1.8之后推出的元注解！\n@Retention: 表示注解保留周期\n@Target: 表示注解可以使用在什么地方\n@Documented: 注解写入文档\n@Inherited : 子类继承父类的注解（子类没有任何注解修饰）\n@Repeatable : 表示注解的属性可以重复！@Repeatable通俗来讲，就是注解容器！\n说完原生注解，说说功能性注解：\njdk自定了一些功能性注解，帮助我们更加方便的开发程序！\n@Deprecated:用于标志过时的类、方法和成员变量\n@Override:用于修饰重写的方法\n@SuppressWarnings:用户忽略@Deprecated标志过的警告\n@SafeVarargs：参数安全类型注解，用于提示用户参数安全（jdk1.7）\n@FunctionalInterface：函数式接口注解，用于定义函数式接口(jdk1.8)")]),a._v(" "),t("p",[a._v("注解的作用：")]),a._v(" "),t("ol",[t("li",[a._v("生成文档，通过代码里标识的元数据生成javadoc文档。")]),a._v(" "),t("li",[a._v("编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。")]),a._v(" "),t("li",[a._v("编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。")]),a._v(" "),t("li",[a._v("运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。")])]),a._v(" "),t("h2",{attrs:{id:"xml配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#xml配置","aria-hidden":"true"}},[a._v("#")]),a._v(" XML配置")]),a._v(" "),t("p",[a._v("XML配置的优缺点：")]),a._v(" "),t("ol",[t("li",[a._v("优点：\n"),t("ol",[t("li",[a._v("XML配置方式进一步降低了耦合，使得应用更加容易扩展，即使对配置文件进一步修改也不需要工程进行修改和重新编译。")]),a._v(" "),t("li",[a._v("在处理大的业务量的时候，用XML配置应该更加好一些。因为XML更加清晰的表明了各个对象之间的关系，各个业务类之间的调用。同时spring的相关配置也能一目了然。")])])]),a._v(" "),t("li",[a._v("缺点：\n配置文件读取和解析需要花费一定的时间，配置文件过多的时候难以管理，无法对配置的正确性进行校验，增加了测试难度。")])])])},[],!1,null,null,null);e.default=r.exports}}]);